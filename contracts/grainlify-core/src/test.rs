#![cfg(test)]

use crate::{GrainlifyContract, GrainlifyContractClient, GovernanceConfig, VotingScheme, VoteType, ProposalStatus};
use soroban_sdk::{testutils::{Address as _, Ledger}, Address, Env, BytesN, symbol_short};

#[test]
fn test_governance_full_flow() {
    let env = Env::default();
    env.mock_all_auths();

    let contract_id = env.register_contract(None, GrainlifyContract);
    let client = GrainlifyContractClient::new(&env, &contract_id);

    let admin = Address::generate(&env);
    let proposer = Address::generate(&env);
    let voter1 = Address::generate(&env);
    let voter2 = Address::generate(&env);

    let config = GovernanceConfig {
        voting_period: 3600, // 1 hour
        execution_delay: 1800, // 30 mins
        quorum_percentage: 5000, // 50%
        approval_threshold: 6000, // 60%
        min_proposal_stake: 10,
        voting_scheme: VotingScheme::OnePersonOneVote,
    };

    // Initialize
    client.init_governance(&admin, &config);

    // Create proposal
    let wasm_hash = BytesN::from_array(&env, &[1u8; 32]);
    let proposal_id = client.create_proposal(&proposer, &wasm_hash, &symbol_short!("TEST"));
    assert_eq!(proposal_id, 0);

    // Cast votes
    client.cast_vote(&voter1, &proposal_id, &VoteType::For);
    client.cast_vote(&voter2, &proposal_id, &VoteType::Against);

    // Try to vote again (should fail because of AlreadyVoted error)
    // In Soroban tests, we can use try_cast_vote which is generated by the client
    let res = client.try_cast_vote(&voter1, &proposal_id, &VoteType::For);
    assert!(res.is_err());

    // Advance time to end voting period
    env.ledger().set_timestamp(3602); // 3601 is > 3600

    // Finalize
    let status = client.finalize_proposal(&proposal_id);
    // 50% approval (1 for, 1 against), threshold is 60%, should be Rejected
    assert_eq!(status, ProposalStatus::Rejected);
}

#[test]
fn test_governance_approval_and_execution() {
    let env = Env::default();
    env.mock_all_auths();

    let contract_id = env.register_contract(None, GrainlifyContract);
    let client = GrainlifyContractClient::new(&env, &contract_id);

    let admin = Address::generate(&env);
    let voter1 = Address::generate(&env);

    let config = GovernanceConfig {
        voting_period: 3600,
        execution_delay: 1800,
        quorum_percentage: 10, // Very low for testing
        approval_threshold: 5000,
        min_proposal_stake: 0,
        voting_scheme: VotingScheme::OnePersonOneVote,
    };

    client.init_governance(&admin, &config);

    let wasm_hash = BytesN::from_array(&env, &[2u8; 32]);
    let proposal_id = client.create_proposal(&admin, &wasm_hash, &symbol_short!("UPGRADE"));

    client.cast_vote(&voter1, &proposal_id, &VoteType::For);

    env.ledger().set_timestamp(3602);

    let status = client.finalize_proposal(&proposal_id);
    assert_eq!(status, ProposalStatus::Approved);

    // Try to execute before delay (should fail)
    let res = client.try_execute_proposal(&voter1, &proposal_id);
    assert!(res.is_err());

    // Advance time past delay
    env.ledger().set_timestamp(3602 + 1801);

    // Execute
    client.execute_proposal(&voter1, &proposal_id);
}
